#region Imports
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Text;
using System.Windows.Forms;
using System.Collections;
using System.Threading;
using System.IO;

using Cognex.VisionPro;
using Cognex.VisionPro.QuickBuild;
using Cognex.VisionPro.QuickBuild.Implementation.Internal;
using Cognex.VisionPro.ToolGroup;
using Cognex.VisionPro.Implementation;
using TechFloor.Shared;
using System.Diagnostics;
using System.Reflection;
using System.Threading.Tasks;
#endregion

#region Program
namespace TechFloor.Vision
{
    public enum AccessLevel { Operator, Supervisor, Administrator }

    public partial class CompositeImageProcessControl : UserControl
    {
        #region Private data
        public enum RunState { Stopped, RunningContinuous, RunningOnce, RunningLive };
        private const int MaximumPeriodMs = 500;
        private const int MinimumPeriodMs = 50;
        private System.Threading.Timer mMaximumGuiPeriodTimer;
        private System.Threading.Timer mMinimumGuiPeriodTimer;
        private bool mMinimumGuiUpdateNeeded = false;
        private bool mHaveUnpaintedResults = false;
        private bool blockGuiControl = false;
        // Queue lengths, for the "all results" and "failing results" queues.
        // To disable the "failing results" queue, set its length to 1.  Queues must always be a least 1 element
        // in length, to hold the current result.
        private const int AllQueueLength = 16;
        private const int FailureQueueLength = 16;
        private PasswordFile mCurrentPasswordFile;
        private string mLoadedVppFilename;
        private OptionsFile mCurrentOptionsFile;
        private CogJobManager mJM = null;
        private bool mAttached = false;
        private int mSelectedJob = 0;
        private AccessLevel mCurrentAccessLevel;
        private CogJobResultHistoryCollection mHistoryCollection = new CogJobResultHistoryCollection();
        private RunState mCurrentRunState = RunState.Stopped;
        private JobData[] mJobData = null;
        private bool mInitError = false;
        private bool mStarted = false;
        private bool mIsClosing = false;
        // resource support for localization
        private Hashtable mResultTextHash;
        private VisionProcessDataObject lastRunResult = new VisionProcessDataObject(VisionProcessDataObjectTypes.ResultData);
        #endregion

        #region Public interface
        /// <summary>
        /// Read-only property to retrieve the CogJobManager.
        /// </summary>
        public CogJobManager JobManager
        {
            get { return mJM; }
        }

        /// <summary>
        /// Read-only property to retrieve the application name.
        /// </summary>
        public string ApplicationName
        {
            get { return mApplicationName; }
        }

        /// <summary>
        /// Read-only property to retrieve the filename of the loaded .vpp file.
        /// </summary>
        public string LoadedVppFilename
        {
            get { return mLoadedVppFilename; }
        }

        /// <summary>
        /// Read-only property indicating if passwords are in use by the generated code or not.
        /// </summary>
        public bool UsingPasswords
        {
            get { return mUsePasswords; }
        }

        /// <summary>
        /// If passwords are in use, returns the current password file.
        /// </summary>
        public PasswordFile CurrentPasswordFile
        {
            get { return mCurrentPasswordFile; }
        }

        /// <summary>
        /// Read-only property indicating the time at which this code was generated by the wizard.
        /// </summary>
        public static DateTime GenerationDateTime
        {
            get { return mGenerationDateTime; }
        }

        /// <summary>
        /// Read-only property indicating the what version of the wizard was used to generate this code.
        /// </summary>
        public static string GeneratedByVersion
        {
            get { return mGeneratedByVersion; }
        }

        /// <summary>
        /// Event fired for every user result produced by a job in the QuickBuild application (.vpp
        /// file).  The event is fired by the job thread itself, so any subscribers must handle this
        /// event in a timely manner.
        /// </summary>
        public event CompositeImageProcessControlUserResultAvailableEventHandler CompositeImageProcessControlUserResultAvailable = null;

        /// <summary>
        /// Clears all results from the result history queues of all jobs.
        /// </summary>
        public void ClearHistoryQueues(object sender, EventArgs e)
        {
            if (this.InvokeRequired)
            {
                // Call this same function on the GUI thread.
                Invoke(new EventHandler(ClearHistoryQueues), new object[] { sender, e });
                return;
            }

            foreach (ICogJobResultHistory h in mHistoryCollection)
            {
                h.Clear();
            }
        }

        /// <summary>
        /// This method serves to close the CompositeImageProcessControl. 
        /// It unsubscribes from the events of the JobManager instance and calls Shutdwon on it.
        /// Therefore this method should be called only at closing the Vision Application.
        /// </summary>
        public void Close()
        {
            AttachToJobManager(false);
            mIsClosing = true;
            if (mJM != null)
            {
                mJM.Shutdown();
                mJM = null;
            }
        }

        public bool BlockControl
        {
            get => blockGuiControl;
            set
            {
                blockGuiControl = value;

                if (InvokeRequired)
                {
                    BeginInvoke(new Action(() => { UpdateControlsEnabled(); }));
                }
                else
                {
                    UpdateControlsEnabled();
                }
            }
        }

        public VisionProcessDataObject LastRunResult => lastRunResult;

        public RunState CurrentRunState => mCurrentRunState;
        #endregion

        #region Initialization
        /*
         * For the vpp filename, first check using the full path supplied when the application
         * was generated.  This is intended for use primarily on developer machines.  If this
         * filename does not exist, then look in the same directory as the executable for
         * the vpp file, using just the filename portion.  This is the expected deployment
         * configuration.
         * 
         * For other files (such as the about box text file and password text file), first
         * check in the same directory as the vpp file, using the full path supplied when the
         * application was generated.  Then look in the same directory as the executable.
         */

        private static string ResolveVppFilename(string filepath = null)
        {
            string fname = string.IsNullOrEmpty(filepath) ? mVppFilename : filepath + mVppFilename;

            // check if the developer vpp file path exists
            if (!System.IO.File.Exists(fname))
            {
                // if not, then try the filename in the same directory as this executable
                string justFilename = System.IO.Path.GetFileName(fname);
                fname = Utility.GetThisExecutableDirectory() + justFilename;
            }

            return fname;
        }

        public CompositeImageProcessControl()
        {
            InitializeComponent();
        }

        private bool PerformRequiredInit(string filepath = null)
        {
            try
            {
                // resolve the quickbuild filename
                string vppFileToLoad = ResolveVppFilename();
                if (!File.Exists(vppFileToLoad) && !File.Exists(mVppFilename))
                {
                    // vpp file does not exist in either developer location or current dir
                    label_controlErrorMessage.Text = ResourceUtility.FormatString("RtVppNotFound", vppFileToLoad, mVppFilename);
                    return false;
                }

                // create, validate & setup the password file
                string passwordfname = Utility.ResolveAssociatedFilename(mVppFilename, "passwords.txt");
                mCurrentPasswordFile = new PasswordFile(passwordfname);
                if (mCurrentPasswordFile.PasswordFileFound && !mCurrentPasswordFile.PasswordFileValid)
                {
                    string quoted = "\"" + mCurrentPasswordFile.PasswordFilename + "\"";
                    label_controlErrorMessage.Text = ResourceUtility.FormatString("RtInvalidPasswordFile", quoted);
                    return false;
                }
                mCurrentPasswordFile.SetDefaultPassword(AccessLevel.Administrator, mDefaultAdministratorPassword);
                mCurrentPasswordFile.SetDefaultPassword(AccessLevel.Supervisor, mDefaultSupervisorPassword);

                // load the QuickBuild project file
                object obj_ = CogSerializer.LoadObjectFromFile(vppFileToLoad) as CogJobManager;
                if (obj_ != null)
                {
                    if ((mJM = (obj_ as CogJobManager)) != null)
                    {   // check for an uninitialized acquisition configuration
                        for (int i = 0; i < mJM.JobCount; ++i)
                        {
                            if (mJM.Job(i).AcqFifoState == CogJobAcqFifoStateConstants.Invalid)
                            {
                                label_controlErrorMessage.Text = ResourceUtility.FormatString("RtUninitializedAcq", mLoadedVppFilename);
                                return false;
                            }
                        }

                        mLoadedVppFilename = vppFileToLoad;
                    }
                }
                else
                    return false;

                // try
                // {
                //     mJM = (CogJobManager)CogSerializer.LoadObjectFromFile(vppFileToLoad);
                // }
                // catch (Exception ex)
                // {
                //     label_controlErrorMessage.Text = ResourceUtility.GetString("RtErrorLoadingVpp") + ex.Message;
                //     return false;
                // }
                // 
                // mLoadedVppFilename = vppFileToLoad;
                // 
                // // check for an uninitialized acquisition configuration
                // for (int i = 0; i < mJM.JobCount; ++i)
                // {
                //     if (mJM.Job(i).AcqFifoState == CogJobAcqFifoStateConstants.Invalid)
                //     {
                //         label_controlErrorMessage.Text = ResourceUtility.FormatString("RtUninitializedAcq", mLoadedVppFilename);
                //         return false;
                //     }
                // }
            }
            catch (Exception ex)
            {
                label_controlErrorMessage.Text = ex.Message;
                Debug.WriteLine($"{GetType().Name}.{MethodBase.GetCurrentMethod().Name}: Exception={ex.Message}");
                return false;
            }

            return true;
        }

        private void StartApplication(string filepath = null)
        {
            if (mStarted)
                return;

            mStarted = true;
            mInitError = !PerformRequiredInit(filepath);

            if (mInitError)
            {
                // cogRecordDisplay1.Hide();
                cogRecordsDisplay1.Hide();
                tabControlJobTabs.Hide();
                UpdateControlsEnabled();
                return;
            }

            // create options file, read
            mCurrentOptionsFile = new OptionsFile();
            mCurrentOptionsFile.Read();

            // set the job manager to always generate user result records, even if nothing
            // was added to the user queue within QuickBuild
            mJM.UserQueueResultCreation = CogUserQueueResultCreationConstants.Always;

            // Flush queues
            Utility.FlushAllQueues(mJM);

            // Set up stats
            for (int i = 0; i < mJM.JobCount; i++)
                mJM.Job(i).ThroughputAlgorithm = CogJobThroughputAlgorithmConstants.MovingAverage;

            ResetStatisticsForAllJobs();

            try
            {
                Wizard_FormLoad();
            }
            catch (System.ArgumentOutOfRangeException)
            {
                // do nothing - handles case where fewer jobs than expected are
                // present in job manager
            }

            try
            {
                // resolve the logo filename
                // string logoFilename = Utility.ResolveAssociatedFilename(mVppFilename, "logo.bmp");
                //pictureBox_Logo.Image = new System.Drawing.Bitmap(logoFilename);

                // size the logo area to the needed height, and center the bitmap in that area
                // int width = pictureBox_Logo.Size.Width;
                // pictureBox_Logo.SizeMode = PictureBoxSizeMode.AutoSize;
                // int height = pictureBox_Logo.Size.Height;
                // pictureBox_Logo.SizeMode = PictureBoxSizeMode.CenterImage;
                // pictureBox_Logo.Size = new System.Drawing.Size(width, height + 4);
            }
            catch (System.ArgumentException)
            {
                // do nothing - handles case where logo bitmap is not supplied
            }

            AttachToJobManager(true);
            UpdateGUIForSelectedJobChange(-1);

            // select the first tab page to start
            if (tabControlJobTabs.TabPages.Count > 0)
                tabControlJobTabs.SelectedTab = tabControlJobTabs.TabPages[0];

            SetResultBarCurrent();

            // size result history window to number of jobs (or 8 max)
            const int maxJobsToSizeTo = 8;
            //int rowHeight = cogJobResultHistoryCollectionEdit1.SelectorControlHeight;
            //int totalHeight = rowHeight * (mJM.JobCount > maxJobsToSizeTo ? maxJobsToSizeTo : mJM.JobCount) + 8;

            // int newPanel1Height = totalHeight + panel1.Height - cogJobResultHistoryCollectionEdit1.Height;
            // if (panel1.Height < newPanel1Height)
            //     panel1.Height = newPanel1Height;
            
            if (mJM.JobCount > maxJobsToSizeTo)
            {
                // scale height of each row to fit remaining jobs (up to 10)
                const int maxJobsToScaleTo = 10;
                int scaleToFit = mJM.JobCount > maxJobsToScaleTo ? maxJobsToScaleTo : mJM.JobCount;
                //int controlSpace = cogJobResultHistoryCollectionEdit1.Height - 4;
                //cogJobResultHistoryCollectionEdit1.SelectorControlHeight = controlSpace / scaleToFit;
            }

            // setup the gui update timers
            mMaximumGuiPeriodTimer = new System.Threading.Timer(new System.Threading.TimerCallback(mMaximumGuiPeriodTimer_Elapsed), null, MaximumPeriodMs, MaximumPeriodMs);
            mMinimumGuiUpdateNeeded = false;
            mHaveUnpaintedResults = false;
            mMinimumGuiPeriodTimer = new System.Threading.Timer(new System.Threading.TimerCallback(mMinimumGuiPeriodTimer_Elapsed), null, MinimumPeriodMs, MinimumPeriodMs);

            // call required IO function
            mJM.IOPostLoadSetup(true);

            // enable IO if selected by options file
            if (mCurrentOptionsFile.EnableIOAtStartup)
            {
                try
                {
                    mJM.IOEnable = true;
                }
                catch (Cognex.VisionPro.Exceptions.CogException) { }
            }

            // start heartbeats, if QuickBuild app is configured for them
            mJM.RequestHeartbeat();
        }

        public void LoadControl(string filepath = null)
        {
            mCurrentAccessLevel = AccessLevel.Administrator;

            if (!DesignMode)
                StartApplication(filepath);
        }

        private void AttachToJobManager(bool attach)
        {
            // attach and detach our event handlers/etc
            if (attach)
            {
                if (mAttached)
                    return;

                try
                {
                    Wizard_AttachPropertyProviders();
                }
                catch (System.ArgumentOutOfRangeException)
                {
                    // do nothing - handles case where fewer jobs than expected are
                    // present in job manager
                }

                mAttached = true;

                // Create a collection of history items for each job.
                // Preserve the history of any jobs that we already have - create new items for any
                // new jobs.
                CogJobResultHistoryCollection jobs = new CogJobResultHistoryCollection();
                bool changed = false;

                for (int j = 0; j < mJM.JobCount; ++j)
                {
                    int i = mHistoryCollection.IndexOf(mJM.Job(j).Name);

                    if (i != -1)
                    {
                        if (i != jobs.Count)
                            changed = true;

                        jobs.Add(mHistoryCollection[i]);
                    }
                    else
                    {
                        jobs.Add(new CogJobResultHistoryGated(mJM.Job(j).Name, AllQueueLength, FailureQueueLength));
                        changed = true;
                    }
                }

                if (jobs.Count != mHistoryCollection.Count)
                    changed = true;

                if (changed)
                {
                    mHistoryCollection = jobs;
                    // cogJobResultHistoryCollectionEdit1.Subject = jobs;
                    mSelectedJob = 0;
                }

                foreach (CogJobResultHistoryGated hist in mHistoryCollection)
                {
                    hist.CurrentItemChanged += new EventHandler(cogJobResultHistory_CurrentItemChanged);
                    hist.InternalQueue.CurrentQueueChanged += new EventHandler(cogJobResultHistory_RequestImmediateUpdate);
                    hist.InternalQueue.CurrentItemChanged += new EventHandler(cogJobResultHistory_RequestImmediateUpdate);
                }

                mJM.Stopped += new CogJobManager.CogJobManagerStoppedEventHandler(mJM_Stopped);
                mJM.UserResultAvailable += new CogJobManager.CogUserResultAvailableEventHandler(mJM_UserResultAvailable);
                mJM.Changed += new CogChangedEventHandler(mJM_ChangedHandler);

                for (int i = 0; i < mJM.JobCount; ++i)
                {
                    mJM.Job(i).Running += new CogJob.CogJobRunningEventHandler(Job_Running);
                    mJM.Job(i).ImageQueueOverflowed += new CogJob.CogImageQueueOverflowedEventHandler(Job_ImageQueueOverflowed);
                }

                // pull off and handle any items currently in the UserQueue
                HandleUserResults();

                // update the state of controls to reflect any changes made in config mode
                UpdateControlsEnabled();
                UpdateOnlineStatus();
            }
            else
            {
                if (!mAttached)
                    return;

                Wizard_DetachPropertyProviders();
                mAttached = false;

                foreach (CogJobResultHistoryGated hist in mHistoryCollection)
                {
                    hist.CurrentItemChanged -= new EventHandler(cogJobResultHistory_CurrentItemChanged);
                    hist.InternalQueue.CurrentQueueChanged -= new EventHandler(cogJobResultHistory_RequestImmediateUpdate);
                    hist.InternalQueue.CurrentItemChanged -= new EventHandler(cogJobResultHistory_RequestImmediateUpdate);
                }

                mJM.Stopped -= new CogJobManager.CogJobManagerStoppedEventHandler(mJM_Stopped);
                mJM.UserResultAvailable -= new CogJobManager.CogUserResultAvailableEventHandler(mJM_UserResultAvailable);
                mJM.Changed -= new CogChangedEventHandler(mJM_ChangedHandler);

                for (int i = 0; i < mJM.JobCount; ++i)
                {
                    mJM.Job(i).Running -= new CogJob.CogJobRunningEventHandler(Job_Running);
                    mJM.Job(i).ImageQueueOverflowed -= new CogJob.CogImageQueueOverflowedEventHandler(Job_ImageQueueOverflowed);
                }
            }
        }
        #endregion

        #region Runtime implementation
        public void RunOnce(int lightmodel = 0, int triggerdelay = 0, VisionProcessDataObject argument = null)
        {
            Task.Run(() => {
                // Clean up control text
                ClearControlText();
                // Set argument to trigger
                SetArguments(argument);
                // Set light value
                FireSetLight(lightmodel);
                // Set trigger delay
                Task.Delay(triggerdelay);
                // Trigger on
                ExecuteProcess();
                return 0;
                // We could wait now, so we any exceptions are thrown, but that 
                // would make the code synchronous. Instead, we continue only if 
                // the task fails.
            }).ContinueWith(t => {
                // This is always true since we ContinueWith OnlyOnFaulted,
                // But we add the condition anyway so resharper doesn't bark.
                if (t.Exception != null) throw t.Exception;
                // Utility.FlushAllQueues(mJM);
            }, default, TaskContinuationOptions.OnlyOnFaulted, TaskScheduler.FromCurrentSynchronizationContext());
        }

        public void SetArguments(VisionProcessDataObject argument)
        {
            if (InvokeRequired)
                BeginInvoke(new Action(() => { InvokeSetArguments(argument); }));
            else
                InvokeSetArguments(argument);
        }

        protected void InvokeSetArguments(VisionProcessDataObject argument)
        {
            if (argument == null || argument.DataObjectType != VisionProcessDataObjectTypes.ProcessArgument)
                return;

            try
            {
                foreach (KeyValuePair<int, object> item in argument.Items)
                {
                    CogDictionary element = ((Cognex.VisionPro.CogDictionary)mJM.Job(0).VisionTool.UserData["ScriptData"]);

                    switch ((ProcessArguments)item.Key)
                    {
                        case ProcessArguments.ProcessType:
                            {
                                element["ProcessType"] = Convert.ToInt32(item.Value);
                                textBox_Job0_PROCESS.Text = item.Value.ToString();
                            }
                            break;
                        case ProcessArguments.CenterXOffsetLimit:
                            {
                                element["CenterXOffsetLimit"] = Convert.ToDouble(item.Value);
                                textBox_Job0_LIMITX.Text = item.Value.ToString();
                            }
                            break;
                        case ProcessArguments.CenterYOffsetLimit:
                            {
                                element["CenterYOffsetLimit"] = Convert.ToDouble(item.Value);
                                textBox_Job0_LIMITY.Text = item.Value.ToString();
                            }
                            break;
                        case ProcessArguments.MatchPatternIndex:
                            break;
                        case ProcessArguments.MatchScoreLimit:
                            break;
                        case ProcessArguments.MatchAcceptScore:
                            {
                                element["AcceptedPatternMathScore"] = Convert.ToDouble(item.Value);
                                textBox_Job0_SCORELIMIT.Text = item.Value.ToString();
                            }
                            break;
                        case ProcessArguments.MatchScaleLimitLow:
                        case ProcessArguments.MatchScaleLimitUpper:
                            break;
                        case ProcessArguments.MatchAngleMin:
                        case ProcessArguments.MatchAngleMax:
                            break;
                        case ProcessArguments.UseCenterPattern:
                            {
                                element["UsingReelCenterPattern"] = Convert.ToBoolean(item.Value);
                                checkBox_Job0_USEREELCENTERPATTERN.Checked = Convert.ToBoolean(item.Value);
                            }
                            break;
                        case ProcessArguments.UseFoundPatternVerify:
                            {
                                element["UsingVerify"] = Convert.ToDouble(item.Value);
                                checkBox_Job0_USEFOUNDCIRCLEVERIFY.Checked = Convert.ToBoolean(item.Value);
                            }
                            break;
                        case ProcessArguments.RMSErrorLimit:
                            {
                                element["RMSErrorLimit"] = Convert.ToDouble(item.Value);
                                textBox_Job0_RMSERROR.Text = item.Value.ToString();
                            }
                            break;
                        case ProcessArguments.SearchMaskRadius_0: // Reel 7 inch
                            {
                                element["Reel7Radius"] = Convert.ToDouble(item.Value);
                                textBox_Job0_REEL7.Text = item.Value.ToString();
                            }
                            break;
                        case ProcessArguments.SearchMaskRadius_1: // Reel 13 inch
                            {
                                element["Reel13Radius"] = Convert.ToDouble(item.Value);
                                textBox_Job0_REEL13.Text = item.Value.ToString();
                            }
                            break;
                        case ProcessArguments.SearchMaskRadial_0:
                        case ProcessArguments.SearchMaskRadial_1:
                            break;
                        case ProcessArguments.VerifyMaskRadius_0: // Reel 7 inch
                        case ProcessArguments.VerifyMaskRadius_1: // Reel 13 inch
                        case ProcessArguments.VerifyMaskRadial_0:
                        case ProcessArguments.VerifyMaskRadial_1:
                            break;
                        case ProcessArguments.TargetPointRadius_0:
                            {
                                element["Reel13Radius"] = Convert.ToDouble(item.Value);
                                textBox_Job0_TARGETPOINT.Text = item.Value.ToString();
                            }
                            break;
                        case ProcessArguments.MaxFindQrCount:
                        case ProcessArguments.MaxFind2DMatrixCount:
                        case ProcessArguments.MaxFind1DBarcodeCount:
                        case ProcessArguments.MaxFindBarcodeTimeout: // 0 is Not use
                            break;
                        case ProcessArguments.TowerBasePointMode:
                            {
                                element["FindBasePointMode"] = Convert.ToInt32(item.Value);
                                textBox_Job0_BASEPOINTMODE.Text = item.Value.ToString();
                            }
                            break;
                        case ProcessArguments.TowerBasePointReferenceX:
                            {
                                element["ReferenceOffsetX"] = Convert.ToDouble(item.Value);
                                textBox_Job0_REFERENCEX.Text = item.Value.ToString();
                            }
                            break;
                        case ProcessArguments.TowerBasePointReferenceY:
                            {
                                element["ReferenceOffsetY"] = Convert.ToDouble(item.Value);
                                textBox_Job0_REFERENCEY.Text = item.Value.ToString();
                            }
                            break;
                        case ProcessArguments.CartGuidePointMode:
                            {
                                element["FindGuidePointMode"] = Convert.ToInt32(item.Value);
                                textBox_Job0_GUIDEPOINTMODE.Text = item.Value.ToString();
                            }
                            break;
                        case ProcessArguments.CartGuidePointPitchX:
                            {
                                element["GuidePitchX"] = Convert.ToDouble(item.Value);
                                textBox_Job0_PITCHX.Text = item.Value.ToString();
                            }
                            break;
                        case ProcessArguments.CartGuidePointPitchY:
                            {
                                element["GuidePitchY"] = Convert.ToDouble(item.Value);
                                textBox_Job0_PITCHY.Text = item.Value.ToString();
                            }
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                Trace.WriteLine($"{GetType().Name}.{MethodBase.GetCurrentMethod().Name}: Exception={ex.Message}");
                MessageBox.Show($"{GetType().Name}.{MethodBase.GetCurrentMethod().Name}: Exception={ex.Message}");
            }
        }

        private void ClearControlText()
        {
            if (InvokeRequired)
            {
                BeginInvoke(new Action(() =>
                {
                    textBox_Job0_CODE.Text = string.Empty;
                    textBox_Job0_STATUS.Text = string.Empty;
                    textBox_Job0_PSTIME.Text = string.Empty;
                    textBox_Job0_TOTALTIME.Text = string.Empty;
                    textBox_Job0_MESSAGE.Text = string.Empty;
                    textBox_Job0_SCORE.Text = string.Empty;
                    textBox_Job0_SCALING.Text = string.Empty;
                    textBox_Job0_RMSERRORVALUE.Text = string.Empty;
                    textBox_Job0_CENTERX.Text = string.Empty;
                    textBox_Job0_CENTERY.Text = string.Empty;
                    textBox_Job0_RADIUS.Text = string.Empty;
                    textBox_Job0_DECODEDATA.Text = string.Empty;
                    textBox_Job0_CARTTYPE.Text = string.Empty;
                    textBox_Job0_SLOTEMPTY.Text = string.Empty;
                    textBox_Job0_REMAINED.Text = string.Empty;
                    textBox_Job0_QRCOUNT.Text = string.Empty;
                    textBox_Job0_BARCODEPPM.Text = string.Empty;
                    textBox_Job0_REMAINEDPPM.Text = string.Empty;
                }));
            }
            else
            {
                textBox_Job0_CODE.Text = string.Empty;
                textBox_Job0_STATUS.Text = string.Empty;
                textBox_Job0_PSTIME.Text = string.Empty;
                textBox_Job0_TOTALTIME.Text = string.Empty;
                textBox_Job0_MESSAGE.Text = string.Empty;
                textBox_Job0_SCORE.Text = string.Empty;
                textBox_Job0_SCALING.Text = string.Empty;
                textBox_Job0_RMSERRORVALUE.Text = string.Empty;
                textBox_Job0_CENTERX.Text = string.Empty;
                textBox_Job0_CENTERY.Text = string.Empty;
                textBox_Job0_RADIUS.Text = string.Empty;
                textBox_Job0_DECODEDATA.Text = string.Empty;
                textBox_Job0_CARTTYPE.Text = string.Empty;
                textBox_Job0_SLOTEMPTY.Text = string.Empty;
                textBox_Job0_REMAINED.Text = string.Empty;
                textBox_Job0_QRCOUNT.Text = string.Empty;
                textBox_Job0_BARCODEPPM.Text = string.Empty;
                textBox_Job0_REMAINEDPPM.Text = string.Empty;
            }
        }

        private void ExecuteProcess()
        {
            if (mJM.JobsRunningState != CogJobsRunningStateConstants.None)
                return;

            try
            {   // update control state here to prevent an error from a quick button double click
                mCurrentRunState = RunState.RunningOnce;
                UpdateControlsEnabled();

                // Reset last run result
                lastRunResult.Clear();
                //Utility.FlushAllQueues(mJM);
                mJM.Run();
                // note that mJM_Stopped will be called when run is complete
            }
            catch (Cognex.VisionPro.Exceptions.CogNotRunnableException ex)
            {
                mCurrentRunState = RunState.Stopped;
                UpdateControlsEnabled();
            }
            catch (Cognex.VisionPro.Exceptions.CogNotStoppedException ex)
            {
                // do nothing in this case - we're already running
            }
            catch (Cognex.VisionPro.Exceptions.CogException ex)
            {
                mCurrentRunState = RunState.Stopped;
                UpdateControlsEnabled();
                MessageBox.Show(ResourceUtility.GetString("RtUnexpectedErrorQB") + ex.Message, mApplicationName);
            }
            catch (System.InvalidOperationException ex)
            {
                Debug.WriteLine($"Exception: {ex.Message}");
            }
            catch (Exception ex)
            {
                mCurrentRunState = RunState.Stopped;
                UpdateControlsEnabled();
                MessageBox.Show($"Exception={ex.Message}", mApplicationName);
            }
            catch
            {
                mCurrentRunState = RunState.Stopped;
                UpdateControlsEnabled();
                MessageBox.Show("Occurred unknown exception!", mApplicationName);
            }
        }

        private void btnRun_Click(object sender, System.EventArgs e)
        {
            ClearHistoryQueues(sender, e);

            // if (mJM.JobsRunningState != CogJobsRunningStateConstants.None)
            //     return;
            // 
            // // update control state here to prevent an error from a quick button doubleclick
            // mCurrentRunState = RunState.RunningOnce;
            // UpdateControlsEnabled();
            // 
            // try
            // {
            //     mJM.Run();
            // 
            //     // note that mJM_Stopped will be called when run is complete
            // }
            // catch (Cognex.VisionPro.Exceptions.CogNotStoppedException)
            // {
            //     // do nothing in this case - we're already running
            // }
            // catch (Cognex.VisionPro.Exceptions.CogException ex)
            // {
            //     mCurrentRunState = RunState.Stopped;
            //     UpdateControlsEnabled();
            //     MessageBox.Show(ResourceUtility.GetString("RtUnexpectedErrorQB") + ex.Message, mApplicationName);
            // }

            ClearControlText();
            ExecuteProcess();
        }

        // private void btnRunCont_Click(object sender, System.EventArgs e)
        // {
        //     if (mCurrentRunState == RunState.RunningContinuous)
        //     {
        //         // Stop continuous
        //         mJM.Stop();
        // 
        //         // note that mJM_Stopped will be called when job manager has completed this stop
        //         // request
        //     }
        //     else
        //     {
        //         // update control state here to prevent an error from a quick button doubleclick
        //         mCurrentRunState = RunState.RunningContinuous;
        //         UpdateControlsEnabled();
        // 
        //         try
        //         {
        //             mJM.RunContinuous();
        //         }
        //         catch (Cognex.VisionPro.Exceptions.CogNotStoppedException)
        //         {
        //             // do nothing in this case - we're already running
        //         }
        //         catch (Cognex.VisionPro.Exceptions.CogException ex)
        //         {
        //             mCurrentRunState = RunState.Stopped;
        //             UpdateControlsEnabled();
        //             MessageBox.Show(ResourceUtility.GetString("RtUnexpectedErrorQB") + ex.Message, mApplicationName);
        //         }
        //     }
        // }

        // Enable or disable controls based on our current run state
        private void UpdateControlsEnabled()
        {
            if (InvokeRequired)
            {
                BeginInvoke(new Action(() => {
                    ChangeControlsEnabled();
                }));
            }
            else
            {
                ChangeControlsEnabled();
            }
        }

        private void ChangeControlsEnabled()
        {
            try
            {
                // Enable or disable controls based on our current run state
                bool running = mCurrentRunState != RunState.Stopped;
                bool runningLive = mCurrentRunState == RunState.RunningLive;
                bool runningContinuous = mCurrentRunState == RunState.RunningContinuous;
                bool currentJobCanLive = mJM != null && mJM.JobCount > mSelectedJob && mJM.Job(mSelectedJob).AcqFifo != null;
                bool canConfig = !running && mCurrentAccessLevel == AccessLevel.Administrator;
                bool canSaveSettings = !running && mCurrentAccessLevel >= AccessLevel.Supervisor;

                btnRun.Enabled = (!mInitError && !running && !blockGuiControl);
                button_Configuration.Enabled = (!mInitError && canConfig && !blockGuiControl);
                button_SaveSettings.Enabled = (!mInitError && canSaveSettings && !blockGuiControl);

                // live display button is enabled if the current job can run live and either
                //   we're not running and the live display button is "up" or
                //   we are running and the live display button is "down"
                // checkBox_LiveDisplay.Enabled = (!mInitError && !running && !blockGuiControl) && currentJobCanLive &&
                //     ((mCurrentRunState == RunState.Stopped && checkBox_LiveDisplay.Checked == false) ||
                //     (mCurrentRunState == RunState.RunningLive && checkBox_LiveDisplay.Checked == true));
                // 
                checkBox_LiveDisplay.Enabled = (!mInitError && !blockGuiControl) && currentJobCanLive &&
                    ((mCurrentRunState == RunState.Stopped && checkBox_LiveDisplay.Checked == false) ||
                    (mCurrentRunState == RunState.RunningLive && checkBox_LiveDisplay.Checked == true));

                button_ResetStatistics.Enabled = (!mInitError && !runningLive && !blockGuiControl);
                button_ResetStatisticsForAllJobs.Enabled = (!mInitError && !runningLive && !blockGuiControl);
                buttonOpenLight.Enabled = (!mInitError && !running && !blockGuiControl);
                Wizard_EnableControls(blockGuiControl ? true : running);
                buttonBasePointRun.Enabled = (!mInitError && !running && !blockGuiControl);
                buttonGuidePointRun.Enabled = (!mInitError && !running && !blockGuiControl);

                // update the monitor window for live display
                // int count = (mJM == null ? 0 : mJM.JobCount);
                // 
                // for (int j = 0; j < count; ++j)
                // {
                //     if (j < cogJobResultHistoryCollectionEdit1.SelectorControls.Count)
                //     {
                //         Control ctl = (Control)cogJobResultHistoryCollectionEdit1.SelectorControls[mHistoryCollection[j]];
                // 
                //         if (runningLive)
                //         {
                //             bool waitingForStop = !checkBox_LiveDisplay.Enabled;
                //             ctl.Enabled = !waitingForStop && (mJM.Job(j).AcqFifo != null) && (j == mSelectedJob || mJM.Job(j).State == CogJobStateConstants.Stopped);
                //         }
                //         else
                //             ctl.Enabled = true;
                //     }
                // }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"{GetType().Name}.{MethodBase.GetCurrentMethod().Name}: Exception={ex.Message}");
            }
        }

        private void UpdateOnlineStatus()
        {
            // update the online/offline status indication
            // check if update needed
            // if (label_Online.Tag != null && (bool)label_Online.Tag == mJM.IOEnable)
            //     return;
            // 
            // string resStr = mJM.IOEnable ? "RtSystemOnline" : "RtSystemOffline";
            // string displayStr = ResourceUtility.GetString(resStr);
            // label_Online.Text = displayStr;
            // label_Online.Tag = mJM.IOEnable;
        }

        private void HandleUserResults()
        {
            // take the latest result and push it into a queue

            ICogRecord result = mJM.UserResult();
            if (result != null)
            {
                string jobName = (string)result.SubRecords["JobName"].Content;
                int jobIndex = Utility.GetJobIndexFromName(mJM, jobName);

                // note - ignore unknown job names
                if (jobIndex >= 0)
                {
                    // push the result into the appropriate history queue
                    mHistoryCollection[jobIndex].AddNewUserResult(result);

                    // pass the result on to any listeners
                    CompositeImageProcessControlUserResultAvailableEventHandler delegateCopy = CompositeImageProcessControlUserResultAvailable;

                    if (delegateCopy != null)
                    {
                        delegateCopy(this, new CompositeImageProcessControlUserResultAvailableEventArgs(jobIndex, result));
                    }

                    lock (mMinimumGuiPeriodTimer)
                    {
                        mHaveUnpaintedResults = true;
                    }
                }
            }
        }

        private void mJM_UserResultAvailable(object sender, CogJobManagerActionEventArgs e)
        {
            HandleUserResults();
            UpdateGuiIfNeeded();
        }

        private void mJM_ImageAvailable(object sender, CogJobActionEventArgs e)
        {
            if (this.InvokeRequired)
                BeginInvoke(new Action(() => { AttachProcessedImage(sender, e); }));
            else
                AttachProcessedImage(sender, e);
        }

        // called when new images are available in live video mode only
        private void AttachProcessedImage(object sender, CogJobActionEventArgs e)
        {
            try
            {
                // if (this.InvokeRequired)
                // {
                //     // Call this same function on the GUI thread.
                //     // Invoke currently has a bug, and it is fixed in .NET2.0
                //     IAsyncResult async = BeginInvoke(new CogJob.CogImageAvailableEventHandler(mJM_ImageAvailable), new object[] { sender, e });
                //     while (!async.IsCompleted && !async.AsyncWaitHandle.WaitOne(300, false)) ;
                //     EndInvoke(async);
                //     return;
                // }

                // display the image if it is from the currently selected job (otherwise ignore it)
                CogJob j = (CogJob)sender;
                int idx = Utility.GetJobIndexFromName(mJM, j.Name);

                if (idx == mSelectedJob)
                {
                    //cogRecordDisplay1.Image = j.Image();
                    cogRecordsDisplay1.Display.Image = j.Image();
                }
            }
            catch { }
        }

        private void Job_Running(object sender, CogJobActionEventArgs e)
        {   // handles:
            //   - gui updates for job run commands issued via IO
            if (this.InvokeRequired)
                BeginInvoke(new Action(() => { InvokeRunning(sender, e); }));
            else
                InvokeRunning(sender, e);
        }

        private void InvokeRunning(object sender, CogJobActionEventArgs e)
        {
            try
            {
                // if (this.InvokeRequired)
                // {
                //     // Call this same function on the GUI thread.
                //     // No need to wait for it here, so ignore the asyncresult return value and return immediately
                //     BeginInvoke(new CogJob.CogJobRunningEventHandler(Job_Running), new object[] { sender, e });
                //     return;
                // }

                // if we are getting this event because the live button was pressed, then we don't have
                // any work to do
                bool isLive = mCurrentRunState == RunState.RunningLive;
                if (isLive)
                    return;

                RunState newrunstate = RunState.Stopped;

                switch (e.Action)
                {
                    case CogActionConstants.RunningContinuous:
                        newrunstate = RunState.RunningContinuous;
                        break;
                    case CogActionConstants.RunningSingle:
                        newrunstate = RunState.RunningOnce;
                        break;
                    default:
                        break;
                }

                // only perform gui changes if we haven't done them already
                if (mCurrentRunState != newrunstate)
                {
                    mCurrentRunState = newrunstate;
                    UpdateControlsEnabled();
                }
            }
            catch { }
        }

        private void mJM_Stopped(object sender, CogJobManagerActionEventArgs e)
        {
            // handles:
            //    - exit from continuous mode
            //    - completion of a single run ("run once")
            //    - exit from live mode
            if (this.InvokeRequired)
                BeginInvoke(new Action(() => { ProcessResults(sender, e); }));
            else
                ProcessResults(sender, e);
        }

        private void ProcessResults(object sender, CogJobManagerActionEventArgs e)
        {
            try
            {
                // if (this.InvokeRequired)
                // {
                //     // Call this same function on the GUI thread.
                //     // No need to wait for it here, so ignore the asyncresult return value and return immediately
                //     BeginInvoke(new CogJobManager.CogJobManagerStoppedEventHandler(mJM_Stopped), new object[] { sender, e });
                //     return;
                // }

                bool stoppingLive = mCurrentRunState == RunState.RunningLive || checkBox_LiveDisplay.Checked;
                mCurrentRunState = RunState.Stopped;

                if (stoppingLive)
                {
                    RestoreJobStates();

                    // clear any statistics
                    ResetStatisticsForAllJobs();

                    // go back to displaying last result for selected job
                    //cogRecordDisplay1.Image = null;
                    cogRecordsDisplay1.Subject = null;
                    cogRecordsDisplay1.Display.Image = null;
                    UpdateGUIForSelectedJob(true);

                    // Need to make sure the checkbox back to unchecked, in case the stopped event is occurring due
                    // to IO, instead of a button click.
                    // Note that this may cause a "checked == false" event to occur.
                    checkBox_LiveDisplay.Checked = false;
                }

                UpdateGui(null, null);
                UpdateControlsEnabled();
                SetResultBarCurrent();
            }
            catch { }
            finally { FireReportProcessResult(); }
        }

        private void mJM_JobStopped(object sender, CogJobActionEventArgs e)
        {
            if (this.InvokeRequired)
                BeginInvoke(new Action(() => { InvokeJobStopped(sender, e); }));
            else
                InvokeJobStopped(sender, e);
        }

        private void InvokeJobStopped(object sender, CogJobActionEventArgs e)
        {
            if (e.Action == CogActionConstants.StoppedContinuous ||
                e.Action == CogActionConstants.RunningContinuous)
            {
                try
                {
                    // if (this.InvokeRequired)
                    // {
                    //     // Call this same function on the GUI thread.
                    //     // No need to wait for it here, so ignore the asyncresult return value and return immediately
                    //     BeginInvoke(new CogJob.CogJobStoppedEventHandler(mJM_JobStopped), new object[] { sender, e });
                    //     return;
                    // }

                    UpdateControlsEnabled();
                }
                catch { }
            }
        }

        private void mJM_ChangedHandler(object sender, CogChangedEventArgs e)
        {
            if ((e.StateFlags & CogJobManager.SfIOEnable) != 0)
            {
                lock (mMinimumGuiPeriodTimer)
                {
                    mMinimumGuiUpdateNeeded = true;
                }
            }
        }

        private int FindResultHistoryIndex(object sender)
        {
            int jobIndex;

            for (jobIndex = 0; jobIndex < mHistoryCollection.Count; ++jobIndex)
            {
                if (Object.ReferenceEquals(sender, mHistoryCollection[jobIndex]))
                    break;
            }

            if (jobIndex == mHistoryCollection.Count)
                return -1;  // unknown job

            return jobIndex;
        }

        // private CogJobResultHistoryEdit FindResultHistoryEdit(CogJob job)
        // {
        //     int jobIndex = Utility.GetJobIndexFromName(mJM, job.Name);
        //     Cognex.VisionPro.Implementation.Internal.CogToggleButton item =
        //         (Cognex.VisionPro.Implementation.Internal.CogToggleButton)
        //         cogJobResultHistoryCollectionEdit1.SelectorControls[mHistoryCollection[jobIndex]];
        //     return item.Content as CogJobResultHistoryEdit;
        // }

        // sets gui "error occurred" icon for given job to "on"
        private void Job_ImageQueueOverflowed(object sender, CogJobActionEventArgs e)
        {   
            try
            {
                // CogJobResultHistoryEdit edit = FindResultHistoryEdit((CogJob)sender);
                // if (!edit.ErrorIconVisible)
                // {
                //     edit.ErrorIconVisible = true;
                //     edit.ErrorIconClicked += new EventHandler(cogJobResultHistory_ErrorIconClicked);
                // }
            }
            catch { }
        }

        private void cogJobResultHistory_ErrorIconClicked(object sender, System.EventArgs e)
        {
            ICogJobResultHistory history = ((CogJobResultHistoryEdit)sender).Subject;

            // get job name
            int jobIndex = FindResultHistoryIndex(history);
            if (jobIndex < 0)
                return;

            string jobname = mJM.Job(jobIndex).Name;

            // for now, show a brief error message.  in the future, we may bring up a more
            // flexible error log here
            MessageBox.Show(ResourceUtility.FormatString("RtImageQueueOverrun", jobname), mApplicationName, MessageBoxButtons.OK);

            // since the message has been viewed, now clear the sender's error icon display
            // CogJobResultHistoryEdit edit = FindResultHistoryEdit(mJM.Job(jobIndex));
            // edit.ErrorIconVisible = false;
            // edit.ErrorIconClicked -= new EventHandler(cogJobResultHistory_ErrorIconClicked);
        }

        // update the gui when the user changes the currently selected job
        private void UpdateGUIForSelectedJobChange(int oldJob)
        {
            TabPage oldSelected = this.tabControlJobTabs.SelectedTab;
            ArrayList newPagesList = new ArrayList();

            // add in the tabs for the selected job
            // set the selected job text
            Wizard_AddJobTabs(newPagesList);

            // remove all the tabs
            tabControlJobTabs.Controls.Clear();

            // add in the tabs available at current access level
            foreach (TabPage page in newPagesList)
            {
                if (page.Tag == null || Utility.AccessAllowed(page.Tag.ToString(), mCurrentAccessLevel))
                    tabControlJobTabs.Controls.Add(page);
            }
            tabControlJobTabs.Controls.Add(tabPage_JobN_JobStatistics);

            if (tabControlJobTabs.TabPages.Contains(oldSelected))
                this.tabControlJobTabs.SelectedTab = oldSelected;
            else if (tabControlJobTabs.TabPages.Count > 0)
                this.tabControlJobTabs.SelectedTab = tabControlJobTabs.TabPages[0];

            // handle job change while live video enabled
            if (this.mCurrentRunState == RunState.RunningLive && oldJob >= 0)
            {
                // start new job
                this.StartLiveDisplay(mSelectedJob);
                // stop old job
                this.StopLiveDisplay(oldJob);
            }

            UpdateControlsEnabled();
            UpdateStatisticsForJob(mSelectedJob);
        }

        private static string[] _updateDisplayStrings = new string[] { "ShowLastRunRecordForUserQueue", "LastRun" };

        private void UpdateGUIForSelectedJob(bool newSelectedJob)
        {
            // update the image and result bar to reflect the currently selected item of the
            // the currently selected job
            ICogRecord result = mHistoryCollection[mSelectedJob].CurrentItem;

            if (result == null)
                return;

            if (mCurrentRunState != RunState.RunningLive)
            {
                if (mCurrentOptionsFile.EnableImageDisplay)
                {
                    // take the LastRunRecord (for the currently selected job) and put it in the record display.
                    // put an empty record in if no LastRunRecord is available
                    if (!Utility.AddRecordToDisplay(cogRecordsDisplay1, result, _updateDisplayStrings, newSelectedJob))
                        cogRecordsDisplay1.Subject = null;

                    // ICogRecord addrec = Utility.TraverseSubRecords(result, _updateDisplayStrings);
                    // 
                    // if (addrec != null)
                    // {
                    //     // select first non-empty image record, to workaround the fact that the input image tool
                    //     // adds an empty subrecord to the LastRun record when it is disabled (when an image file
                    //     // tool is used, for example)
                    //     for (int i = 0; i < addrec.SubRecords.Count; ++i)
                    //     {
                    //         ICogImage img = addrec.SubRecords[i].Content as ICogImage;
                    //         if (img != null && img.Height != 0 && img.Width != 0)
                    //         {
                    //             cogRecordsDisplay1.SelectedRecordKey = addrec.RecordKey + "." + addrec.SubRecords[i].RecordKey;
                    //             //cogRecordDisplay1.Image = img;
                    //             break;
                    //         }
                    //     }
                    //     
                    //     // ICogImage img = addrec.SubRecords[0].Content as ICogImage;
                    //     // 
                    //     // if (img != null && img.Height != 0 && img.Width != 0)
                    //     //     cogRecordDisplay1.Image = img;
                    // }
                }
                // else
                //     cogRecordDisplay1.Image = null;
                else
                    cogRecordsDisplay1.Subject = null;
            }

            SetResultBarCurrent();
        }

        private void UpdateGUIForJob(int idx)
        {
            // update the tab pages to reflect the currently selected item of the the currently
            // selected job
            ICogRecord result = mHistoryCollection[idx].CurrentItem;

            // fill in the tab results
            Wizard_UpdateJobResults(idx, result);
            FireTurnOffLight();
        }

        private void SetResultBarCurrent()
        {
            try
            {
                string text;
                CogRunStatus rs = null;

                text = mJM.Job(mSelectedJob).Name;

                if (mCurrentRunState == RunState.RunningLive)
                    text += ": Live";
                else
                {
                    ICogRecord result = mHistoryCollection[mSelectedJob].CurrentItem;

                    if (result != null)
                    {
                        rs = (CogRunStatus)result.SubRecords["RunStatus"].Content;
                        text += ": " + rs.Result.ToString();// (string)this.mResultTextHash[rs.Result];
                    }
                }

                label_ResultBar.Text = text;
                label_ResultBar.BackColor = GetColorFromRunStatus(rs);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"{GetType().Name}.{MethodBase.GetCurrentMethod().Name}: Exception={ex.Message}");
                MessageBox.Show($"{GetType().Name}.{MethodBase.GetCurrentMethod().Name}: Exception={ex.Message}");
            }
        }

        private System.Drawing.Color GetColorFromRunStatus(CogRunStatus status)
        {
            System.Drawing.Color color;
            if (status != null)
            {
                switch (status.Result)
                {
                    case CogToolResultConstants.Accept:
                        color = System.Drawing.Color.FromArgb(0, 200, 0);
                        break;
                    case CogToolResultConstants.Warning:
                        color = System.Drawing.Color.Yellow;
                        break;
                    case CogToolResultConstants.Reject:
                    case CogToolResultConstants.Error:
                    default:
                        color = System.Drawing.Color.Red;
                        break;
                }
            }
            else
                color = System.Drawing.Color.FromKnownColor(KnownColor.ControlDark);

            return color;
        }

        private void cogJobResultHistoryCollectionEdit1_SelectedJobIndexChanged(object sender, System.EventArgs e)
        {
            // if (cogJobResultHistoryCollectionEdit1.Subject != null && cogJobResultHistoryCollectionEdit1.SelectedIndex >= 0 &&
            //     cogJobResultHistoryCollectionEdit1.SelectedIndex != mSelectedJob)
            // {
            //     int oldJob = mSelectedJob;
            //     mSelectedJob = cogJobResultHistoryCollectionEdit1.SelectedIndex;
            // 
            //     UpdateGUIForSelectedJobChange(oldJob);
            //     UpdateGUIForSelectedJob(true);
            // }
        }

        private void cogJobResultHistory_CurrentItemChanged(object sender, System.EventArgs e)
        {
            bool newResultForSelectedJob = false;

            int jobIndex = FindResultHistoryIndex(sender);

            if (jobIndex < 0)
                return;

            if (jobIndex == mSelectedJob)
                newResultForSelectedJob = true;

            UpdateGUIForJob(jobIndex);

            // if there is a new result for the selected job, update the gui now
            if (newResultForSelectedJob)
                UpdateGUIForSelectedJob(false);
        }
        #endregion

        #region Live Display
        public void StopLive()
        {
            StopLiveDisplay(mSelectedJob);
        }

        private void StartLiveDisplay(int jobNumber)
        {
            CogJob j = mJM.Job(jobNumber);
            if (j.State == CogJobStateConstants.Stopped)
                j.RunContinuous();
        }

        private void StopLiveDisplay(int jobNumber)
        {
            CogJob j = mJM.Job(jobNumber);
            if (j.State == CogJobStateConstants.RunningContinuous)
                j.Stop();
        }

        private void checkBox_LiveDisplay_CheckedChanged(object sender, System.EventArgs e)
        {
            if (checkBox_LiveDisplay.Checked == true)
            {
                // clear stats
                ResetStatisticsForAllJobs();
                for (int i = 0; i < mJM.JobCount; i++)
                    UpdateStatisticsForJob(i);

                // enable live
                mCurrentRunState = RunState.RunningLive;
                SetResultBarCurrent();
                // cogRecordsDisplay1.Subject = null;

                // save old modes & setup jobs for live
                SetupForLive();

                try
                {
                    StartLiveDisplay(mSelectedJob);
                }
                catch (Cognex.VisionPro.Exceptions.CogException ex)
                {
                    RestoreJobStates();
                    mCurrentRunState = RunState.Stopped;
                    SetResultBarCurrent();
                    MessageBox.Show(ResourceUtility.GetString("RtUnexpectedErrorQB") + ex.Message, mApplicationName);

                    // need to set the checkbox back to unchecked - note that this causes a recurse call
                    // to occur, so the "checked == false" handling below needs to be able to handle this
                    checkBox_LiveDisplay.Checked = false;
                }
            }
            else
            {
                // stop live
                StopLiveDisplay(mSelectedJob);
            }

            UpdateControlsEnabled();
        }

        private void SetupForLive()
        {
            mJobData = new JobData[mJM.JobCount];
            for (int i = 0; i < mJobData.Length; ++i)
            {
                mJobData[i] = new JobData();

                CogJob j = mJM.Job(i);
                mJobData[i].lastRunMode = j.RunMode;
                mJobData[i].lastStartMode = j.StartMode;

                j.StartMode = CogJobStartModeConstants.IssuedAfterAcquisitionCompletes;
                j.RunMode = CogJobRunModeConstants.AcquisitionOnly;
                j.ImageAvailable += new CogJob.CogImageAvailableEventHandler(mJM_ImageAvailable);
                j.Stopped += new CogJob.CogJobStoppedEventHandler(mJM_JobStopped);
            }
        }

        private void RestoreJobStates()
        {
            // restore all jobs start & run modes
            for (int idx = 0; idx < mJM.JobCount; ++idx)
            {
                CogJob j = mJM.Job(idx);
                j.StartMode = mJobData[idx].lastStartMode;
                j.RunMode = mJobData[idx].lastRunMode;
                j.ImageAvailable -= new CogJob.CogImageAvailableEventHandler(mJM_ImageAvailable);
                j.Stopped -= new CogJob.CogJobStoppedEventHandler(mJM_JobStopped);
            }

            // done with jobdata
            mJobData = null;
        }
        #endregion

        #region Login
        private void comboBox_Login_SelectionChangeCommitted(object sender, System.EventArgs e)
        {
            // AccessLevel newAccessLevel = ((AccessLevel_Localized)(comboBox_Login.SelectedItem)).val;
            // 
            // // prompt for a password - only update accessLevel if promt is successful
            // if (PromptForAccessLevelChange(newAccessLevel))
            //    mCurrentAccessLevel = newAccessLevel;
            // 
            // // update gui to reflect current accessLevel
            // foreach (AccessLevel_Localized al in comboBox_Login.Items)
            //    if (al.val == mCurrentAccessLevel)
            //        comboBox_Login.SelectedItem = al;
            // this.UpdateGUIForSelectedJobChange(-1);
        }

        private bool PromptForAccessLevelChange(AccessLevel newAccessLevel)
        {
            // not using passwords, or going "down" in access level - always allowed
            if (!mUsePasswords || newAccessLevel <= mCurrentAccessLevel)
                return true;

            string expected = mCurrentPasswordFile.GetPasswordForAccessLevel(newAccessLevel);
            if (expected != "")
            {
                // get password from user
                FormPasswordPrompt prompt = new FormPasswordPrompt();
                prompt.Text = ResourceUtility.FormatString("RtEnterPassword", newAccessLevel.ToString());
                DialogResult result = prompt.ShowDialog(this);
                if (result != DialogResult.OK)
                    return false;
                if (prompt.Password != expected)
                {
                    MessageBox.Show(ResourceUtility.GetString("RtInvalidPassword2"), ResourceUtility.GetString("RtInvalidPassword"));
                    return false;
                }
            }

            return true;
        }
        #endregion

        #region Other buttons (config, save settings, about)
        private void button_Configuration_Click(object sender, System.EventArgs e)
        {
            // detach from job manager before displaying edit control
            AttachToJobManager(false);

            // put up a new dialog containing QB editor
            FormQB frm = new FormQB(mJM);
            frm.ShowDialog(this);
            frm.Dispose();

            // prompt for save of vpp file
            string vpp = mLoadedVppFilename;
            string quotedvpp = "\"" + vpp + "\"";
            string saveButtonName = ResourceUtility.GetString("RtSaveSettingsButton");
            string quotedSaveButtonName = "\"" + saveButtonName + "\"";
            string promptStr = ResourceUtility.FormatString("RtSaveSettingsTextAfterConfig", quotedvpp, quotedSaveButtonName);
            PromptToSaveSettings(promptStr);

            // re-attach
            AttachToJobManager(true);
        }

        private void PromptToSaveSettings(string promptString)
        {
            DialogResult result = MessageBox.Show(this, promptString, ResourceUtility.GetString("RtSaveSettingsTitle"), MessageBoxButtons.YesNo);
            if (result == DialogResult.Yes)
            {
                if (mJM.JobsRunningState != CogJobsRunningStateConstants.None)
                {
                    MessageBox.Show(ResourceUtility.GetString("RtErrorSavingVpp_Running"), mApplicationName);
                    return;
                }

                string vpp = mLoadedVppFilename;
                try
                {
                    bool wasAttached = mAttached;
                    if (wasAttached)
                        AttachToJobManager(false);

                    // save the QuickBuild project file
                    try
                    {
                        Utility.FlushAllQueues(mJM);
                        CogSerializer.SaveObjectToFile(mJM, vpp);
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show(ResourceUtility.FormatString("RtErrorSavingVpp", vpp) + ex.Message, mApplicationName);
                    }

                    if (wasAttached)
                        AttachToJobManager(true);
                }
                catch (Exception ex)
                {
                    MessageBox.Show(ResourceUtility.FormatString("RtErrorSavingVpp", vpp) + ex.Message, mApplicationName);
                }
            }
        }

        private void button_SaveSettings_Click(object sender, System.EventArgs e)
        {
            string promptStr = ResourceUtility.FormatString("RtSaveSettingsText", $"\"{mLoadedVppFilename}\"");
            PromptToSaveSettings(promptStr);
        }

        private void button_About_Click(object sender, System.EventArgs e)
        {
            // resolve the aboutbox text filename
            string aboutFilename = Utility.ResolveAssociatedFilename(mVppFilename, "about.txt");

            FormAbout about = new FormAbout(aboutFilename, this);
            about.Text = ResourceUtility.FormatString("RtAboutTitle", this.Text);
            about.ShowDialog(this);
        }
        #endregion

        #region GUI update support
        /*
         * The GUI update goals of this application are as follows:
         * 
         * 1.  We would like most, if not all, GUI updates to occur in the context of a
         *     QuickBuild job thread.  This helps to avoid the case where GUI updates
         *     occur in a separate thread, causing job threads to block momentarily at
         *     arbitrary times (for some time critical applications, this behavior is
         *     not acceptable).
         * 
         * 2.  We would like to avoid repainting the GUI every time a new job result is
         *     available, as this rate is application dependent and can occur hundreds of
         *     times per second.  Repainting at a very high rate wastes CPU cycles.
         * 
         * The GUI update strategy of this application is as follows:
         * 
         * 1.  Two flags track the status of GUI updates:
         *     mHaveUnpaintedResults - tracks when new results are available that have
         *       not yet been painted.  This flag is set every time a new user result
         *       is generated by the application.
         *     mMinimumGuiUpdateNeeded - indicates that painting is now required - we've
         *       passed the minimum amount of time between paints and new results are
         *       available.
         * 
         * 2.  A timer (mMinimumGuiPeriodTimer) is set to go off every 50 ms.  If the
         *     handler for this timer determines the we have unpainted results, then it
         *     sets the mMinimumGuiUpdateNeeded flag.
         * 
         * 3.  Every time a new user result is generated, the mMinimumGuiUpdateNeeded
         *     flag is checked (in the "UserResultAvailable" event handler).  If an update
         *     is needed, it is performed immediately, which causes it to occur in the context
         *     of a job thread.
         * 
         * 4.  A second timer (mMaximumGuiPeriodTimer) is set to go off every 500 ms.  This
         *     timer handles the case where user results are generated relatively slowly, or
         *     they stop being generated for some reason (triggers stop occurring, etc).  The
         *     event handler for this timer performs a paint.  In this case, the paint is not
         *     performed in a job thread.
         * 
         * 5.  The mMaximumGuiPeriodTimer is reset every time a paint occurs, such that its
         *     handler is only called if a paint has not happened in the last 500 ms.
         */

        private void mMaximumGuiPeriodTimer_Elapsed(object obj)
        {
            UpdateGui(null, null);
        }

        private void UpdateGui(object sender, System.EventArgs e)
        {
            if (this.InvokeRequired)
                BeginInvoke(new Action(() => { InvokeUpdateControls(sender, e); }));
            else
                InvokeUpdateControls(sender, e);
        }

        private void InvokeUpdateControls(object sender, EventArgs e)
        {
            try
            {
                if (mIsClosing)
                    return;

                // if (this.InvokeRequired)
                // {
                //     // Call this same function on the GUI thread.
                //     // Invoke currently has a bug, and it is fixed in .NET2.0
                //     IAsyncResult async = BeginInvoke(new System.EventHandler(UpdateGui), new object[] { sender, e });
                //     while (!mIsClosing && !async.IsCompleted && !async.AsyncWaitHandle.WaitOne(300, false)) ;
                // 
                //     // if the CompositeImageProcessControl is closing, updating the GUI is not necessary any more, besides it
                //     // might also cause deadlock
                //     if (mIsClosing)
                //     {
                //         async.AsyncWaitHandle.Close();
                //     }
                //     else
                //     {
                //         EndInvoke(async);
                //     }
                // 
                //     return;
                // }

                // update everything we can on the gui from here

                lock (mMinimumGuiPeriodTimer)
                {
                    mHaveUnpaintedResults = false;
                }

                for (int i = 0; i < mHistoryCollection.Count; ++i)
                {
                    CogJobResultHistoryGated hist = (CogJobResultHistoryGated)mHistoryCollection[i];
                    hist.SnapshotNow();
                }

                UpdateStatisticsForJob(mSelectedJob);
                UpdateOnlineStatus();

                this.Update();

                ResetMaximumGuiUpdateTimer();
                ResetMinimumGuiUpdateTimer();
                lock (mMinimumGuiPeriodTimer)
                {
                    mMinimumGuiUpdateNeeded = false;
                }
            }
            catch { }
        }

        private void ResetMaximumGuiUpdateTimer()
        {
          mMaximumGuiPeriodTimer.Change(MaximumPeriodMs, MaximumPeriodMs);
        }

        private void ResetMinimumGuiUpdateTimer()
        {
          mMinimumGuiPeriodTimer.Change(MinimumPeriodMs, MinimumPeriodMs);
        }

        private void UpdateGuiIfNeeded()
        {
            // this function is called every time a new user result is available.  it performs
            // a paint if the minimum amount of time between paints has elapsed.
            bool updateNeeded;
            lock (mMinimumGuiPeriodTimer)
            {
                updateNeeded = mMinimumGuiUpdateNeeded;
            }

            if (updateNeeded)
                UpdateGui(null, null);
        }

        private void mMinimumGuiPeriodTimer_Elapsed(object obj)
        {
            // the minimum amount of time between paints has elapsed.  if we have any unpainted
            // results, then indicate that the next generated user result should perform a paint.
            bool updateNow = false;

            lock (mMinimumGuiPeriodTimer)
            {
                if (!mMinimumGuiUpdateNeeded && !mHaveUnpaintedResults)
                    ResetMaximumGuiUpdateTimer();
                else
                {
                    updateNow = true;
                    mMinimumGuiUpdateNeeded = true;
                }
            }

            if (updateNow && mCurrentRunState == RunState.Stopped)
                UpdateGui(null, null);
        }

        private void cogJobResultHistory_RequestImmediateUpdate(object sender, System.EventArgs e)
        {
            // called when the user interacts with the scrolling history display (selects a different
            // queue or result record for viewing)
            lock (mMinimumGuiPeriodTimer)
            {
                mMinimumGuiUpdateNeeded = true;
            }
        }
        #endregion

        #region Statistics
        private void ResetStatisticsForAllJobs()
        {
            for (int i = 0; i < mJM.JobCount; i++)
                ResetStatisticsForJob(i);
        }

        private void ResetStatisticsForJob(int i)
        {
            mJM.Job(i).ResetAllStatistics();
            mJM.Job(i).RestartThroughputCalculation();
        }

        private void button_ResetStatisticsForAllJobs_Click(object sender, System.EventArgs e)
        {
            ResetStatisticsForAllJobs();
            lock (mMinimumGuiPeriodTimer)
            {
                mMinimumGuiUpdateNeeded = true;
            }
        }

        private void button_ResetStatistics_Click(object sender, System.EventArgs e)
        {
            ResetStatisticsForJob(mSelectedJob);
            lock (mMinimumGuiPeriodTimer)
            {
                mMinimumGuiUpdateNeeded = true;
            }
        }

        private void UpdateStatisticsForJob(int i)
        {
            // don't update statistics when showing live video
            bool runningLive = mCurrentRunState == RunState.RunningLive;
            if (runningLive)
                return;

            CogJob j = mJM.Job(i);
            textBox_JobN_TotalIterations.Text = j.TotalJobIterations.ToString();
            textBox_JobN_TotalAccept.Text = j.TotalVisionToolAccepts.ToString();
            string percentStr = string.Empty;
            if (j.TotalJobIterations > 0)
            {
                double p = j.TotalVisionToolAccepts * 100.0 / j.TotalJobIterations;
                percentStr = p.ToString("0.0");
            }

            textBox_JobN_TotalAccept_Percent.Text = percentStr;
            textBox_JobN_TotalReject.Text = j.TotalVisionToolRejects.ToString();
            textBox_JobN_TotalWarning.Text = j.TotalVisionToolWarnings.ToString();
            textBox_JobN_TotalError.Text = j.TotalVisionToolErrors.ToString();
            textBox_JobN_TotalAcquisitions.Text = j.TotalAcquisitions.ToString();
            textBox_JobN_TotalAcquisitionErrors.Text = j.TotalAcquisitionErrors.ToString();
            textBox_JobN_TotalAcquisitionOverruns.Text = j.TotalAcquisitionOverruns.ToString();

            if (j.TotalJobThroughputMax != 0)
            {
                textBox_JobN_Throughput.Text = j.TotalJobThroughput.ToString("0.000");
                textBox_JobN_MinThroughput.Text = j.TotalJobThroughputMin.ToString("0.000");
                textBox_JobN_MaxThroughput.Text = j.TotalJobThroughputMax.ToString("0.000");
            }
            else
            {
                string waiting = ResourceUtility.GetString("RtStatsWaiting");
                textBox_JobN_Throughput.Text = waiting;
                textBox_JobN_MinThroughput.Text = waiting;
                textBox_JobN_MaxThroughput.Text = waiting;
            }
        }
        #endregion

        #region Light control
        public event EventHandler<int> RequestToSetLight;
        public event EventHandler RequestToTurnOffLight;
        public event EventHandler RequestToOpenLightControlWindow;
        public event EventHandler ReportProcessResult;
        public event EventHandler RequestToCheckTowerBasePoints;
        public event EventHandler RequestToCheckCartGuidePoints;

        private void FireSetLight(int model)
        {
            RequestToSetLight?.Invoke(this, model);
        }

        private void FireTurnOffLight()
        {
            RequestToTurnOffLight?.Invoke(this, EventArgs.Empty);
        }

        private void FireReportProcessResult()
        {
            ReportProcessResult?.Invoke(this, EventArgs.Empty);
        }

        private void OnClickButtonLight(object sender, EventArgs e)
        {
            RequestToOpenLightControlWindow?.Invoke(this, EventArgs.Empty);
        }
        #endregion

        private void OnClickButtonBasePointRun(object sender, EventArgs e)
        {
            RequestToCheckTowerBasePoints?.Invoke(this, EventArgs.Empty);
        }

        private void OnClickButtonGuidePointRun(object sender, EventArgs e)
        {
            RequestToCheckCartGuidePoints?.Invoke(this, EventArgs.Empty);
        }
    }

    #region Internal helper classes
    internal class JobData
    {
      public CogJobStartModeConstants lastStartMode = CogJobStartModeConstants.IssuedAfterAcquisitionCompletes;
      public CogJobRunModeConstants lastRunMode = CogJobRunModeConstants.AcquisitionAndImageProcessing;
    }

    // helper class to store localized name and enum value, for use in combo box display
    internal class AccessLevel_Localized
    {
        public AccessLevel_Localized(AccessLevel v, string t)
        {
            val = v;
            text = t;
        }

        public override string ToString()
        {
            // return the localized name
            return text;
        }

        public AccessLevel val;
        public string text;
    }
    #endregion

    #region UserResultAvailable event support
    public class CompositeImageProcessControlUserResultAvailableEventArgs
    {
        public int JobIndex;
        public ICogRecord Result;

        public CompositeImageProcessControlUserResultAvailableEventArgs(int jobIndex, ICogRecord result)
        {
            JobIndex = jobIndex;
            Result = result;
        }
    }

    public delegate void CompositeImageProcessControlUserResultAvailableEventHandler(object sender, CompositeImageProcessControlUserResultAvailableEventArgs e);
    #endregion
}
#endregion